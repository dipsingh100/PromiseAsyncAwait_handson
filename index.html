<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promise Async Await</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1 class="title">Promise Async Await</h1>
    <div class="question">
      <h3>
        Q1. Write one example explaining how you can write a callback function?
        <br />
        Ans.-
      </h3>
      <pre>
        function getSum(num1, num2, callback){
            var sum = num1 + num2;
            callback(sum);
        }
        
        function displaySum(sum){
            console.log("Sum is: " + sum);
        }
        
        getSum(2,3,displaySum);
        </pre>
        <hr>
    </div>
    <div class="question">
      <h3>
        Q2. "Write a callback function to print numbers from 1 to 7, in which 1 should be printed after 1 sec, 2 should be printed after 2 sec, 3 should be printed after 3 sec, and so on. 

        Explain callback hell.
        Numbers
        1
        2
        3
        4
        5
        6
        7"
        <br />
        Ans.-
      </h3>
      <pre>
        setTimeout(() => {
            console.log("1");
            setTimeout(() => {
              console.log("2");
              setTimeout(() => {
                console.log("3");
                setTimeout(() => {
                  console.log("4");
                  setTimeout(() => {
                    console.log("5");
                    setTimeout(() => {
                      console.log("6");
                      setTimeout(() => {
                        console.log("7");
                      }, 7000);
                    }, 6000);
                  }, 5000);
                }, 4000);
              }, 3000);
            }, 2000);
          }, 1000);
        </pre>
        Callback hell, also known as the pyramid of doom, is a situation that arises when multiple asynchronous operations are nested within each other using callback functions. It occurs when callbacks are used to handle the flow of execution in asynchronous JavaScript code, leading to deeply nested and difficult-to-read code structures. The code will grow horizontally and if one function fail then the whole functions pyramid break.
        <hr>
    </div>
    <div class="question">
      <h3>
        Q3. "Write the promise function to print numbers from 1 to 7, in which 1 should be printed after 1 sec, 2 should be printed after 2 sec, 3 should be printed after 3 sec, and so on. 

        Numbers
        1
        2
        3
        4
        5
        6
        7"
        <br />
        Ans.-
      </h3>
      <pre>
        function delayPrint(number, delay) {
            return new Promise((resolve, reject) => {
              setTimeout(() => {
                resolve(number);
              }, delay);
            });
          }
          
          delayPrint(1,1000).then((val)=>{
              console.log(val)
              delayPrint(2,2000).then((val)=>{
                  console.log(val)
                  delayPrint(3,3000).then((val)=>{
                      console.log(val)
                      delayPrint(4,4000).then((val)=>{
                          console.log(val)
                          delayPrint(5,5000).then((val)=>{
                              console.log(val)
                              delayPrint(6,6000).then((val)=>{
                                  console.log(val)
                                  delayPrint(7,7000).then((val)=>{
                                      console.log(val)
                                  })
                              })
                          })
                      })
                  })
              })
          })
        </pre>
        <hr>
    </div>
    <div class="question">
      <h3>
        Q4. "Create a promise function accepting an argument, if yes is passed to the function then it should go to resolved state and print Promise Resolved, and if nothing is passed 
        then it should go to reject the state and catch the error and print Promise Rejected "?
        <br />
        Ans.-
      </h3>
      <pre>
        function promiseFunc(arg){
            return  new Promise((resolve, reject)=>{
                if(arg==="yes")
                    resolve("Promise Resolved");
                else
                    reject("Promise Rejected");
            })
        }
        
        promiseFunc().then((resolvevalue)=>{console.log(resolvevalue)})
            .catch((rejectvalue)=>{console.log(rejectvalue)})
        
        </pre>
        <hr>
    </div>
    <div class="question">
      <h3>
        Q5. Create examples to explain callback function?
        <br />
        Ans.-
      </h3>
      <pre>
        function AgeCalculator(byear,cyear){
            return cyear-byear
        }
        
        function displayAge(callback,byear,cyear){
            var age = callback(byear, cyear)
            console.log("Age is :",age)
        }
        
        displayAge(AgeCalculator, 2001, 2023)
        </pre>
        The AgeCalculator function takes two parameters: byear (birth year) and cyear (current year). It calculates the difference between the current year and the birth year, representing the person's age. The result is returned.
        The displayAge function takes three parameters: callback (a callback function), byear, and cyear. It is responsible for displaying the age calculated by the callback function.
        Inside the displayAge function, the callback function is invoked with byear and cyear as arguments, and the result is stored in the age variable.
        Finally, the age is displayed using console.log() with the message "Age is:" followed by the value of the age variable.
        <hr>
    </div>
    <div class="question">
      <h3>
        Q6. Create examples to explain callback hell function?
        <br />
        Ans.-
      </h3>
      <pre>
        function asyncOperation1(callback) {
            setTimeout(() => {
              console.log("Async operation 1");
              callback();
            }, 1000);
          }
          
          function asyncOperation2(callback) {
            setTimeout(() => {
              console.log("Async operation 2");
              callback();
            }, 2000);
          }
          
          function asyncOperation3(callback) {
            setTimeout(() => {
              console.log("Async operation 3");
              callback();
            }, 3000);
          }
          
          function asyncOperation4(callback) {
            setTimeout(() => {
              console.log("Async operation 4");
              callback();
            }, 1000);
          }
          
          function startAsyncOperations() {
            asyncOperation1(() => {
              asyncOperation2(() => {
                asyncOperation3(() => {
                  asyncOperation4(() => {
                    console.log("All async operations completed");
                  });
                });
              });
            });
          }
          
          startAsyncOperations();
          
        </pre>
        In this example, we have four asynchronous operations (asyncOperation1, asyncOperation2, asyncOperation3, asyncOperation4), each simulating an asynchronous task using setTimeout.
The startAsyncOperations function initiates a series of nested callbacks to execute the asynchronous operations sequentially. As each operation completes, it calls the next operation in the chain using a callback function. This is an example of callback hell, where multiple levels of nested callbacks create a pyramid-like structure.      
        <hr>
    </div>
    <div class="question">
      <h3>
        Q7. Create examples to explain promises function?
        <br />
        Ans.-
      </h3>
      <pre>
        function asyncOperation() {
            return new Promise((resolve, reject) => {
              setTimeout(() => {
                resolve("Operation completed successfully");
                reject("An error occurred");
              }, 2000);
            });
          }
          
          asyncOperation()
            .then((result) => {
              console.log(result);
            })
            .catch((error) => {
              console.error(error);
            });
          
        </pre>
        In this example, we define an asyncOperation function that returns a promise. Inside the promise, we simulate an asynchronous operation using setTimeout. If the operation is successful, we call resolve with the result. If an error occurs, we call reject with an error message.
We call the asyncOperation function and use the .then() method to handle the resolved promise, printing the result. We also use the .catch() method to handle any rejected promise, printing the error message.
        <hr>
    </div>
    <div class="question">
      <h3>
        Q8. Create examples to explain async await function?
        <br />
        Ans.-
      </h3>
      <pre>
        function delay(ms) {
            return new Promise((resolve) => {
              setTimeout(resolve, ms);
            });
          }
          
          async function asyncOperation() {
            console.log("Start");
            await delay(2000);
            console.log("Async operation completed");
          }
          
          asyncOperation();
          
        </pre>
        In this example, the asyncOperation function is declared with the async keyword, indicating that it is an asynchronous function. Inside the function, we use the await keyword to wait for the delay promise to resolve. The function execution is paused at the await statement until the promise is resolved. Once the promise is resolved, the execution continues.
        <hr>
    </div>
    <div class="question">
      <h3>
        Q9. Create examples to explain promise.all function?
        <br />
        Ans.-
      </h3>
      <pre>  
          const promise1 = new Promise((resolve, reject)=>{
            setTimeout(()=>{
              resolve("Promise 1 resolved")
            },2000)
          });
          const promise2 = new Promise((resolve, reject)=>{
            setTimeout(()=>{
              resolve("Promise 2 resolved")
            },1000)
          });
          const promise3 = new Promise((resolve, reject)=>{
            setTimeout(()=>{
              resolve("Promise 3 resolved")
            },1500)
          });
                    
          Promise.all([promise1, promise2, promise3])
            .then((results) => {
              console.log(results);
            })
            .catch((error) => {
              console.error(error);
            });
          
        </pre>
        In this example, we have three promises representing asynchronous operations with different delays. We use Promise.all() to wait for all promises to resolve. Once all promises are resolved, the results are passed to the .then() callback and logged. If any of the promises are rejected, the error is caught in the .catch() callback.
        <hr>
    </div>
    <script src="script.js"></script>
</body>
</html>